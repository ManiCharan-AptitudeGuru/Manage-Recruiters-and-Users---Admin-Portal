// RecruiterList.js
import React, { useState, useEffect } from "react";
import { confirmAlert } from "react-confirm-alert";
import "react-confirm-alert/src/react-confirm-alert.css";
import { toast } from "react-toastify";
import {
  getRecruiters,
  approveRecruiter,
  rejectRecruiter,
  verifyRecruiter,
} from "../services/recruiterService";
import styled from "styled-components";

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 1rem;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
`;

const Thead = styled.thead`
  background-color: #4a90e2;
  color: white;
  text-transform: uppercase;
`;

const Th = styled.th`
  padding: 12px 15px;
  text-align: left;
  border-bottom: 2px solid #ddd;
`;

const Tr = styled.tr`
  &:nth-child(even) {
    background-color: #f9f9f9;
  }
  &:hover {
    background-color: #f1f1f1;
  }
`;

const Td = styled.td`
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #ddd;
`;

const Button = styled.button`
  background-color: ${(props) =>
    props.type === "approve"
      ? "#28a745"
      : props.type === "reject"
      ? "#dc3545"
      : "#ffc107"};
  border: none;
  color: white;
  padding: 8px 16px;
  margin: 0 5px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 0.9rem;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: ${(props) =>
      props.type === "approve"
        ? "#218838"
        : props.type === "reject"
        ? "#c82333"
        : "#e0a800"};
  }
`;

const Pagination = styled.div`
  display: flex;
  justify-content: center;
  margin-top: 20px;
`;

const PageButton = styled.button`
  margin: 0 5px;
  padding: 5px 10px;
  background-color: ${(props) => (props.active ? "#4a90e2" : "#f1f1f1")};
  color: ${(props) => (props.active ? "white" : "black")};
  border: none;
  cursor: pointer;
`;

const Modal = styled.div`
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  z-index: 1;
`;

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 0;
`;

const RecruiterList = () => {
  const [recruiters, setRecruiters] = useState([]);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(10);
  const [search, setSearch] = useState("");
  const [status, setStatus] = useState("all");
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedRecruiter, setSelectedRecruiter] = useState(null);
  const [reason, setReason] = useState("");

  useEffect(() => {
    const fetchRecruiters = async () => {
      try {
        const { recruiters, total } = await getRecruiters({
          page,
          status,
          search,
        });
        setRecruiters(recruiters);
        setTotal(total);
      } catch (error) {
        toast.error("Failed to fetch recruiters");
      }
    };
    fetchRecruiters();
  }, [page, status, search]);

  const handleApprove = async (id, reason) => {
    try {
      await approveRecruiter(id, reason);
      toast.success("Recruiter approved successfully");
    } catch (error) {
      toast.error("Failed to approve recruiter");
    }
  };

  const handleReject = async (id, reason) => {
    try {
      await rejectRecruiter(id, reason);
      toast.success("Recruiter rejected successfully");
    } catch (error) {
      toast.error("Failed to reject recruiter");
    }
  };

  const handleVerify = async (id) => {
    try {
      await verifyRecruiter(id);
      toast.success("Recruiter verified successfully");
    } catch (error) {
      toast.error("Failed to verify recruiter");
    }
  };

  const handlePageChange = (newPage) => {
    setPage(newPage);
  };

  const handleSearchChange = (e) => {
    setSearch(e.target.value);
  };

  const handleStatusChange = (e) => {
    setStatus(e.target.value);
  };

  const handleModalOpen = (recruiter) => {
    setSelectedRecruiter(recruiter);
    setModalOpen(true);
  };

  const handleModalClose = () => {
    setModalOpen(false);
  };

  const handleReasonChange = (e) => {
    setReason(e.target.value);
  };

  return (
    <div>
      <h1>Recruiter List</h1>
      <form>
        <input
          type="search"
          value={search}
          onChange={handleSearchChange}
          placeholder="Search by name or email"
        />
        <select value={status} onChange={handleStatusChange}>
          <option value="all">All</option>
          <option value="approved">Approved</option>
          <option value="rejected">Rejected</option>
        </select>
      </form>
      <Table>
        <Thead>
          <tr>
            <Th>Name</Th>
            <Th>Email</Th>
            <Th>Status</Th>
            <Th>Actions</Th>
          </tr>
        </Thead>
        <tbody>
          {recruiters.map((recruiter) => (
            <Tr key={recruiter._id}>
              <Td>{recruiter.name}</Td>
              <Td>{recruiter.email}</Td>
              <Td>{recruiter.status}</Td>
              <Td>
                <Button
                  type="approve"
                  onClick={() => handleModalOpen(recruiter)}
                >
                  Approve
                </Button>
                <Button
                  type="reject"
                  onClick={() => handleModalOpen(recruiter)}
                >
                  Reject
                </Button>
                <Button
                  type="verify"
                  onClick={() => handleVerify(recruiter._id)}
                >
                  Verify
                </Button>
              </Td>
            </Tr>
          ))}
        </tbody>
      </Table>
      <Pagination>
        {[...Array(Math.ceil(total / limit))].map((_, index) => (
          <PageButton
            key={index}
            active={index + 1 === page}
            onClick={() => handlePageChange(index + 1)}
          >
            {index + 1}
          </PageButton>
        ))}
      </Pagination>
      {modalOpen && (
        <Modal>
          <h2>Approve/Reject Recruiter</h2>
          <p>
            Are you sure you want to{" "}
            {selectedRecruiter.status === "approved" ? "reject" : "approve"}{" "}
            {selectedRecruiter.name}?
          </p>
          <input
            type="text"
            placeholder="Reason (optional)"
            value={reason}
            onChange={handleReasonChange}
          />
          <Button
            type={
              selectedRecruiter.status === "approved" ? "reject" : "approve"
            }
            onClick={() =>
              selectedRecruiter.status === "approved"
                ? handleReject(selectedRecruiter._id, reason)
                : handleApprove(selectedRecruiter._id, reason)
            }
          >
            {selectedRecruiter.status === "approved" ? "Reject" : "Approve"}
          </Button>
          <Button onClick={handleModalClose}>Cancel</Button>
        </Modal>
      )}
      {modalOpen && <Overlay onClick={handleModalClose} />}
    </div>
  );
};

export default RecruiterList;


import React, { useState, useEffect } from "react";
import { confirmAlert } from "react-confirm-alert";
import "react-confirm-alert/src/react-confirm-alert.css";
import { toast } from "react-toastify";
import {
  getUsers,
  updateUser,
  approveCertification,
  rejectCertification,
  verifyUser,
} from "../services/userService";
import styled from "styled-components";

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 1rem;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
`;

const Thead = styled.thead`
  background-color: #4a90e2;
  color: white;
  text-transform: uppercase;
`;

const Th = styled.th`
  padding: 12px 15px;
  text-align: left;
  border-bottom: 2px solid #ddd;
`;

const Tr = styled.tr`
  &:nth-child(even) {
    background-color: #f9f9f9;
  }
  &:hover {
    background-color: #f1f1f1;
  }
`;

const Td = styled.td`
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #ddd;
`;

const Button = styled.button`
  background-color: ${(props) =>
    props.type === "approve"
      ? "#28a745"
      : props.type === "reject"
      ? "#dc3545"
      : "#ffc107"};
  border: none;
  color: white;
  padding: 8px 16px;
  margin: 0 5px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 0.9rem;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: ${(props) =>
      props.type === "approve"
        ? "#218838"
        : props.type === "reject"
        ? "#c82333"
        : "#e0a800"};
  }
`;

const Pagination = styled.div`
  display: flex;
  justify-content: center;
  margin-top: 20px;
`;

const PageButton = styled.button`
  margin: 0 5px;
  padding: 5px 10px;
  background-color: ${(props) => (props.active ? "#4a90e2" : "#f1f1f1")};
  color: ${(props) => (props.active ? "white" : "black")};
  border: none;
  cursor: pointer;
`;

const Modal = styled.div`
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  z-index: 1;
`;

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 0;
`;

const UserList = () => {
  const [users, setUsers] = useState([]);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(10);
  const [search, setSearch] = useState("");
  const [selectedUser, setSelectedUser] = useState(null);
  const [modalOpen, setModalOpen] = useState(false);
  const [reason, setReason] = useState("");

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const { users, total } = await getUsers({ page, search });
        setUsers(users);
        setTotal(total);
      } catch (error) {
        toast.error("Failed to fetch users");
      }
    };
    fetchUsers();
  }, [page, search]);

  const handleUpdateUser = async (id, userData) => {
    try {
      await updateUser(id, userData);
      toast.success("User updated successfully");
    } catch (error) {
      toast.error("Failed to update user");
    }
  };

  const handleApproveCertification = async (id) => {
    try {
      await approveCertification(id);
      toast.success("Certification approved successfully");
    } catch (error) {
      toast.error("Failed to approve certification");
    }
  };

  const handleRejectCertification = async (id, reason) => {
    try {
      await rejectCertification(id, reason);
      toast.success("Certification rejected successfully");
    } catch (error) {
      toast.error("Failed to reject certification");
    }
  };

  const handleVerifyUser = async (id) => {
    try {
      await verifyUser(id);
      toast.success("User verified successfully");
    } catch (error) {
      toast.error("Failed to verify user");
    }
  };

  const handlePageChange = (newPage) => {
    setPage(newPage);
  };

  const handleSearchChange = (e) => {
    setSearch(e.target.value);
  };

  const handleModalOpen = (user) => {
    setSelectedUser(user);
    setModalOpen(true);
  };

  const handleModalClose = () => {
    setModalOpen(false);
  };

  return (
    <div>
      <h1>User List</h1>
      <form>
        <input
          type="search"
          value={search}
          onChange={handleSearchChange}
          placeholder="Search by name or email"
        />
      </form>
      <Table>
        <Thead>
          <tr>
            <Th>Name</Th>
            <Th>Email</Th>
            <Th>Certification Status</Th>
            <Th>Actions</Th>
          </tr>
        </Thead>
        <tbody>
          {users.map((user) => (
            <Tr key={user._id}>
              <Td>{user.name}</Td>
              <Td>{user.email}</Td>
              <Td>{user.certification.status}</Td>
              <Td>
                <Button type="approve" onClick={() => handleModalOpen(user)}>
                  Approve Certification
                </Button>
                <Button type="reject" onClick={() => handleModalOpen(user)}>
                  Reject Certification
                </Button>
                <Button
                  type="verify"
                  onClick={() => handleVerifyUser(user._id)}
                >
                  Verify User
                </Button>
              </Td>
            </Tr>
          ))}
        </tbody>
      </Table>
      <Pagination>
        {[...Array(Math.ceil(total / limit))].map((_, index) => (
          <PageButton
            key={index}
            active={index + 1 === page}
            onClick={() => handlePageChange(index + 1)}
          >
            {index + 1}
          </PageButton>
        ))}
      </Pagination>
      {modalOpen && (
        <Modal>
          <h2>Approve/Reject Certification</h2>
          <p>
            Are you sure you want to{" "}
            {selectedUser.certification.status === "approved"
              ? "reject"
              : "approve"}{" "}
            {selectedUser.name}'s certification?
          </p>
          <input
            type="text"
            placeholder="Reason (optional)"
            value={reason}
            onChange={(e) => setReason(e.target.value)}
          />
          <Button
            type={
              selectedUser.certification.status === "approved"
                ? "reject"
                : "approve"
            }
            onClick={() =>
              selectedUser.certification.status === "approved"
                ? handleRejectCertification(selectedUser._id, reason)
                : handleApproveCertification(selectedUser._id)
            }
          >
            {selectedUser.certification.status === "approved"
              ? "Reject"
              : "Approve"}
          </Button>
          <Button onClick={handleModalClose}>Cancel</Button>
        </Modal>
      )}
      {modalOpen && <Overlay onClick={handleModalClose} />}
    </div>
  );
};

export default UserList;

import React from "react";
import { Link } from "react-router-dom";

const Dashboard = () => {
  return (
    <div>
      <h1>Admin Dashboard</h1>
      <nav>
        <ul>
          <li>
            <Link to="/recruiters">Manage Recruiters</Link>
          </li>
          <li>
            <Link to="/users">Manage Users</Link>
          </li>
        </ul>
      </nav>
    </div>
  );
};

export default Dashboard;

import React, { useState, useEffect } from "react";
import RecruiterList from "../components/RecruiterList";
import {
  getRecruiters,
  approveRecruiter,
  rejectRecruiter,
  verifyRecruiter,
} from "../services/recruiterService";

const RecruitersManagement = () => {
  const [recruiters, setRecruiters] = useState([]);

  useEffect(() => {
    fetchRecruiters();
  }, []);

  const fetchRecruiters = async () => {
    const data = await getRecruiters();
    setRecruiters(data);
  };

  const handleApprove = async (id) => {
    await approveRecruiter(id);
    fetchRecruiters();
  };

  const handleReject = async (id) => {
    await rejectRecruiter(id);
    fetchRecruiters();
  };

  const handleVerify = async (id) => {
    await verifyRecruiter(id);
    fetchRecruiters();
  };

  return (
    <div>
      <h1>Recruiters Management</h1>
      <RecruiterList
        recruiters={recruiters}
        onApprove={handleApprove}
        onReject={handleReject}
        onVerify={handleVerify}
      />
    </div>
  );
};

export default RecruitersManagement;

import React, { useState, useEffect } from 'react';
import UserList from '../components/UserList';
import { getUsers, updateUser, approveCertification, rejectCertification } from '../services/userService';

const UsersManagement = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    const data = await getUsers();
    setUsers(data);
  };

  const handleUpdateUser = async (id) => {
    // Implement update user logic here
    // For simplicity, we'll just refetch the users
    await updateUser(id, { /* updated user data */ });
    fetchUsers();
  };

  const handleApproveCertification = async (id) => {
    await approveCertification(id);
    fetchUsers();
  };

  const handleRejectCertification = async (id) => {
    await rejectCertification(id);
    fetchUsers();
  };

  return (
    <div>
      <h1>Users Management</h1>
      <UserList
        users={users}
        onUpdateUser={handleUpdateUser}
        onApproveCertification={handleApproveCertification}
        onRejectCertification={handleRejectCertification}
      />
    </div>
  );
};

export default UsersManagement;

import axios from 'axios';

const API_URL = 'http://localhost:5000/api/recruiters';

export const getRecruiters = async () => {
  const response = await axios.get(API_URL);
  return response.data;
};

export const approveRecruiter = async (id, reason) => {
  const response = await axios.put(`${API_URL}/approve`, { id, reason });
  return response.data;
};

export const rejectRecruiter = async (id, reason) => {
  const response = await axios.put(`${API_URL}/reject`, { id, reason });
  return response.data;
};

export const verifyRecruiter = async (id) => {
  const response = await axios.put(`${API_URL}/verify/${id}`);
  return response.data;
};

import axios from "axios";

const API_URL = "http://localhost:5000/api/users";

export const getUsers = async () => {
  const response = await axios.get(API_URL);
  return response.data;
};

export const updateUser = async (id, userData) => {
  const response = await axios.put(`${API_URL}/${id}`, userData);
  return response.data;
};

export const approveCertification = async (id) => {
  const response = await axios.put(`${API_URL}/${id}/approve-certification`);
  return response.data;
};

export const rejectCertification = async (id, reason) => {
  const response = await axios.put(`${API_URL}/${id}/reject-certification`, {
    reason,
  });
  return response.data;
};

export const verifyUser = async () => {};

import React from "react";
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
import Dashboard from "./pages/Dashboard";
import RecruitersManagement from "./pages/RecruitersManagement";
import UsersManagement from "./pages/UsersManagement";

function App() {
  return (
    <Router>
      <div className="App">
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/recruiters" element={<RecruitersManagement />} />
          <Route path="/users" element={<UsersManagement />} />
        </Routes>
      </div>
    </Router>
  );
}

export default App;

const mongoose = require("mongoose");

const connectDB = async () => {
  try {
    await mongoose.connect(
      "mongodb+srv://manicharan12:adminPortal@cluster0.2ytlh.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0",
      {
        useNewUrlParser: true,
        useUnifiedTopology: true,
      }
    );
    console.log("MongoDB connected");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;

const Recruiter = require("../models/Recruiter");
const sendEmail = require("../utils/sendEmail");

exports.getRecruiters = async (req, res) => {
  try {
    const { page = 1, status = "all", search = "" } = req.query;
    const limit = 10;
    const skip = (page - 1) * limit;

    let query = {};
    if (status !== "all") {
      query.status = status;
    }
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const total = await Recruiter.countDocuments(query);
    const recruiters = await Recruiter.find(query)
      .select("-password")
      .skip(skip)
      .limit(limit);

    res.json({ recruiters, total, page, limit });
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.approveRecruiter = async (req, res) => {
  try {
    const { id, reason } = req.body;
    const recruiter = await Recruiter.findByIdAndUpdate(
      id,
      { $set: { status: "approved" } },
      { new: true }
    );

    if (!recruiter) {
      return res.status(404).json({ message: "Recruiter not found" });
    }

    await sendEmail(
      recruiter.email,
      "Profile Approved",
      `Your profile has been approved. Reason: ${reason}`
    );

    res.json(recruiter);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.rejectRecruiter = async (req, res) => {
  try {
    const { id, reason } = req.body;
    const recruiter = await Recruiter.findByIdAndUpdate(
      id,
      { $set: { status: "rejected" } },
      { new: true }
    );

    if (!recruiter) {
      return res.status(404).json({ message: "Recruiter not found" });
    }

    await sendEmail(
      recruiter.email,
      "Profile Rejected",
      `Your profile has been rejected. Reason: ${reason}`
    );

    res.json(recruiter);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.verifyRecruiter = async (req, res) => {
  try {
    const { id } = req.params;
    const recruiter = await Recruiter.findByIdAndUpdate(
      id,
      { $set: { verified: true } },
      { new: true }
    );

    if (!recruiter) {
      return res.status(404).json({ message: "Recruiter not found" });
    }

    res.json(recruiter);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

const User = require("../models/User");
const sendEmail = require("../utils/sendEmail");

exports.getUsers = async (req, res) => {
  try {
    const { page = 1, search = "" } = req.query;
    const limit = 10;
    const skip = (page - 1) * limit;

    let query = {};
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const total = await User.countDocuments(query);
    const users = await User.find(query)
      .select("-password")
      .skip(skip)
      .limit(limit);

    res.json({ users, total, page, limit });
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const updatedUser = await User.findByIdAndUpdate(id, req.body, {
      new: true,
    });

    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json(updatedUser);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.approveCertification = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { "certification.status": "approved" } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await sendEmail(
      user.email,
      "Certification Approved",
      "Your certification has been approved."
    );

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.rejectCertification = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { "certification.status": "rejected" } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await sendEmail(
      user.email,
      "Certification Rejected",
      `Your certification has been rejected. Reason: ${reason}`
    );

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.verifyUser = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { verified: true } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

const mongoose = require("mongoose");

const RecruiterSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  role: {
    type: String,
    enum: ["recruiter", "admin"],
    default: "recruiter",
  },
  status: {
    type: String,
    enum: ["pending", "approved", "rejected"],
    default: "pending",
  },
  verified: {
    type: Boolean,
    default: false,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("Recruiter", RecruiterSchema);

const User = require("../models/User");
const sendEmail = require("../utils/sendEmail");

exports.getUsers = async (req, res) => {
  try {
    const { page = 1, search = "" } = req.query;
    const limit = 10;
    const skip = (page - 1) * limit;

    let query = {};
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const total = await User.countDocuments(query);
    const users = await User.find(query)
      .select("-password")
      .skip(skip)
      .limit(limit);

    res.json({ users, total, page, limit });
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const updatedUser = await User.findByIdAndUpdate(id, req.body, {
      new: true,
    });

    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json(updatedUser);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.approveCertification = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { "certification.status": "approved" } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await sendEmail(
      user.email,
      "Certification Approved",
      "Your certification has been approved."
    );

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.rejectCertification = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { "certification.status": "rejected" } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await sendEmail(
      user.email,
      "Certification Rejected",
      `Your certification has been rejected. Reason: ${reason}`
    );

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

exports.verifyUser = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await User.findByIdAndUpdate(
      id,
      { $set: { verified: true } },
      { new: true }
    );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

const mongoose = require("mongoose");

const RecruiterSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  role: {
    type: String,
    enum: ["recruiter", "admin"],
    default: "recruiter",
  },
  status: {
    type: String,
    enum: ["pending", "approved", "rejected"],
    default: "pending",
  },
  verified: {
    type: Boolean,
    default: false,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("Recruiter", RecruiterSchema);

const mongoose = require("mongoose");

const UserSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  certification: {
    type: {
      name: String,
      status: {
        type: String,
        enum: ["pending", "approved", "rejected"],
        default: "pending",
      },
    },
  },
  verified: {
    type: Boolean,
    default: false,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("User", UserSchema);

const express = require("express");
const router = express.Router();
const recruiterController = require("../controllers/recruiterController");

router.get("/", recruiterController.getRecruiters);
router.put("/approve", recruiterController.approveRecruiter);
router.put("/reject", recruiterController.rejectRecruiter);
router.put("/verify/:id", recruiterController.verifyRecruiter);

module.exports = router;

const express = require("express");
const router = express.Router();
const userController = require("../controllers/userController");

router.get("/", userController.getUsers);
router.put("/:id", userController.updateUser);
router.put("/:id/approve-certification", userController.approveCertification);
router.put("/:id/reject-certification", userController.rejectCertification);

module.exports = router;

const nodemailer = require("nodemailer");

const sendEmail = async (to, subject, text) => {
  try {
    const transporter = nodemailer.createTransport({
      host: "smtp.example.com",
      port: 587,
      auth: {
        user: "your-email@example.com",
        pass: "your-password",
      },
    });

    await transporter.sendMail({
      from: "admin@example.com",
      to,
      subject,
      text,
    });

    console.log("Email sent successfully");
  } catch (error) {
    console.error("Error sending email:", error);
  }
};

module.exports = sendEmail;

const express = require("express");
const cors = require("cors");
const connectDB = require("./config/db");
const recruiterRoutes = require("./routes/recruiterRoutes");
const userRoutes = require("./routes/userRoutes");

const app = express();

// Connect to MongoDB
connectDB();

// Middleware
app.use(express.json());
app.use(
  cors({
    origin: "http://localhost:3000",
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true,
  })
);

// Routes
app.use("/api/recruiters", recruiterRoutes);
app.use("/api/users", userRoutes);

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
